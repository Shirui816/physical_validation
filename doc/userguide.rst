Introduction
============

Advances in recent years have made molecular dynamics (MD) simulations a
powerful tool in molecular-level research, allowing the prediction of
experimental observables in the study of systems such as proteins, drug
targets or membranes. The quality of any prediction based on MD results
will, however, strongly depend on the validity of underlying physical
assumptions.

This package is intended to help detecting (sometimes hard-to-spot)
unphysical behavior of simulations, which may have statistically important
influence on their results. It is thereby part of a two-fold approach to
increase the robustness of molecular simulations.

Firstly, it empowers users of MD programs to test the physical validity on
their respective systems and setups. The tests thereby range from simple
post-processing analysis to more involved tests requiring additional
simulations. These tests can be shown to significantly increase the
reliability of MD simulations by catching a number of common simulation
errors violating physical assumptions, such as non-conservative
integrators, deviating from the Boltzmann ensemble, or lack of ergodicity
between degrees of freedom. To render the usage as easy as possible,
parsers for several popular MD program output formats are provided.

Secondly, it can be integrated in MD code testing environements. While
unphysical behavior can be due to poor or incompatible choices of
parameters by the user, it can just as well originate in coding errors
within the program. Physical validation tests can be integrated in the
code-checking mechanism of MD software packages to facilitate the
detection of such bugs. The `physicalvalidation` package is currently
used in the automated code-testing facility of the GROMACS software
package, ensuring that every major releases passes a number of physical
sanity checks performed on selected representative systems before
shipping.

.. note:: We are always looking to enlarge our set of tests. If you are a
   MD user or developer and have suggestions for physical validity tests
   missing in this package, we would love to hear from you! Please
   consider getting in touch with us via our `github page`_.

Simulation Data
===============

The data of simulations to be validated are best represented by objects
of the  :class:`.SimulationData` type. While lower-level functions accepting
bare arrays and numbers are available, the  :class:`.SimulationData` objects
combine ease-of-use and higher stability in form of input testing.

The  :class:`.SimulationData` objects are consisting of information about the
system. This information is collected in objects of different classes, namely

* :obj:`.SimulationData.ensemble` of type :class:`.EnsembleData`:
  Information on the sampled ensemble.
* :obj:`.SimulationData.units` of type :class:`.UnitData`:
  Information on the units used by the simulation program.
* :obj:`.SimulationData.topology` of type :class:`.TopologyData`:
  Information on the topology of the system.
* :obj:`.SimulationData.observables` of type :class:`.ObservableData`:
  Trajectories of observables along the simulation.
* :obj:`.SimulationData.trajectory` of type :class:`.TrajectoryData`:
  Position / velocity / force trajectories along the simulation.

The :class:`.SimulationData` objects can either be constructed
directly from arrays and numbers, or (partially) automatically via parsers.

To facilitate the use of the physical validation suite, simulation results
generated by selected software packages can be automatically created by
:class:`.Parser` objects. The currently supported MD packages are:

* GROMACS: :class:`.GromacsParser`

Package-specific parsers are subclasses of :class:`.Parser`, and need to
redefine the :func:`.Parser.get_simulation_data` returning a
:class:`.SimulationData` object.

.. note:: Currently, the GROMACS parser
   automatically creates the :obj:`.SimulationData.units`,
   :obj:`.SimulationData.observables` and :obj:`.SimulationData.trajectory`
   parts of the object, but requires the user to create a
   :class:`.EnsembleData` and a :class:`.TopologyData` by hand.

.. note:: We are looking to enlarge the collection of parsers to make the
   use of the package as convenient as possible for as many users as
   possible. If your MD program of choice is not supported (yet), please
   consider either writing your own parser and contribute it by creating
   a pull request on the project's `github page`_, or contacting us to
   let us know about your needs and ideally help us getting a fitting
   parser out soon.

.. _example_sec_1:

Examples
--------
The folder `examples/` contains MD simulation result files. Specifically,
the folder `examples/nh1` contains the following GROMACS files (for size
reasons, no trajectory file is included in the distribution):

* `start.gro`: the starting configuration, containing 900 three-site
  water molecules
* `water.top`: the topology of a (flexible) water molecule
* `water.mdp`: the GROMACS input file
* `water.gro`: the end configuration
* `water.edr`: the resulting (binary) energy file

The simulation was ran at constant volume using a Nose-Hoover thermostat
to keep the temperature around its target value. To create a simulation
data object, first the relevant packages and modules are imported:
::

   import numpy as np
   from physicalvalidation.data.gromacs_parser import GromacsParser
   from physicalvalidation.data.simulation_data import TopologyData, EnsembleData

Currently, the GROMACS parser cannot create the topological data.
As there are 900 3-site molecules in the system, the number of atoms is 2700,
and the number of constraints is zero since the water was simulated with flexible
bonds. Without bond constraints, the only reduction of degrees of freedom is due to
the enforced removal of the center-of-mass translation. Finally, the molecule index is denoting
the first atom of each molecule, and is hence the vector `[0, 3, 6, ...]`, while
the number of constraints per molecule is zero.
Creating the toplogical data by hand therefore looks something like this:
::

   topo = TopologyData()
   topo.natoms = 2700
   topo.masses = np.array([15.99940, 1.00800, 1.00800]*900)
   topo.nconstraints = 0
   topo.ndof_total = 2700*3 - 3
   topo.ndof_reduction_tra = 3
   topo.ndof_reduction_rot = 0
   topo.molecule_idx = np.arange(0, 2700, 3)
   topo.nconstraints_per_molecule = np.zeros(900)


The sampled ensemble is canonical (NVT). The side length of the cubic box is
3.01125 nm, while the target temperature of the Nose-Hoover thermostat was set
to 300 K.
::

   NVT_300 = EnsembleData('NVT', natoms=2700, volume=3.01125**3, temperature=300)

A parser is created by giving the path to the GROMACS executable, and telling
whether the simulation was performed at double precision (`False` in our case).
::

   parser = GromacsParser(exe='/path/to/gmx', dp=False)

The simulation data is then created by requesting a :class:`.SimulationData`
object from the created parser, giving the created ensemble and topological
information as input.
::

   nh1_data = parser.get_simulation_data(ensemble=NVT_300, topology=topo,
                                         edr='examples/nh1/water.edr',
                                         gro='examples/nh1/water.gro')


In folder `examples/nh2`, the results of a very similar simulation are
stored. The only difference between the results in `nh1` and `nh2` is
that the first was performed at 300K, while the second was performed at
310K. Creating a second simulation data structure then requires simply
a different ensemble object:
::

   NVT_310 = EnsembleData('NVT', natoms=2700, volume=3.01125**3, temperature=310)
   nh2_data = parser.get_simulation_data(ensemble=NVT_310, topology=topo,
                                         edr='examples/nh2/water.edr',
                                         gro='examples/nh2/water.gro')

In the folders `examples/ber1` and `examples/ber2`, the results
of two additional simulations are stored. Their setup is identical with the
setups in `nh1` and `nh2`, respectively, with the exception of the use of
the Berendsen thermostat instead of Nose-Hoover. Creating additional

Kinetic energy validation
=========================
Kinetic energy tests include testing the likelihood of a trajectory
originating from a Maxwell-Boltzmann distribution and validating the
temperature equipartition between groups of degrees of freedom. For
details on the employed algorithms, please check the respective
function documentations.

Functions
---------
*Maxwell-Boltzmann ensemble validation:*
:func:`physicalvalidation.kineticenergy.check_mb_ensemble`


*Equipartition validation:*
:func:`physicalvalidation.kineticenergy.check_equipartition`

Examples
--------
Using the data structure created in :ref:`example_sec_1`, the kinetic
energy ensemble can be validated as follows:
::

   from physicalvalidation import kineticenergy

   kineticenergy.check_mb_ensemble(nh1_data,
                                   alpha=0.05,
                                   verbose=True)

This will yield the following result, indicating that under the chosen
confidence (:math:`\alpha=0.05`), the null-hypothesis that the energy
is Maxwell-Boltzmann distributed stands:
::

   Kolmogorov-Smirnov test result: p = 0.742541
   Null hypothesis: Kinetic energy is Maxwell-Boltzmann distributed
   Confidence alpha = 0.050000
   Result: Hypothesis stands

In folder `examples/ber1`, the results of a very similar simulation are
stored. The only difference between the results in `nh1` and `ber1` is
that the first was performed at with a Nose-Hoover thermostat, while
the latter was performed using a Berendsen thermostat. Creating a second
simulation data structure only requires changing the path to the
simulation results:
::

   ber1_data = parser.get_simulation_data(ensemble=NVT_300, topology=topo,
                                          edr='examples/ber1/water.edr',
                                          gro='examples/ber1/water.gro')

Unsurprisingly, for these results, the hypothesis of a Maxwell-Boltzmann
distribution is largely rejected:
::

   kineticenergy.check_mb_ensemble(ber1_data,
                                   alpha=0.05,
                                   verbose=True)

yields
::

   Kolmogorov-Smirnov test result: p = 0.000000
   Null hypothesis: Kinetic energy is Maxwell-Boltzmann distributed
   Confidence alpha = 0.050000
   Result: Hypothesis rejected

.. todo:: Equipartition example

Ensemble validation
===================
As the distribution of configurational quantities like the potential
energy :math:`U`, the volume :math:`V` or the chemical potential
:math:`\mu` are in general not known analytically, testing the likelihood
of a trajectory sampling a given ensemble is less straightforward than
for the kinetic energy. However, generally, the ratio of the probability
distribution between samplings of the same ensemble at different state
points (e.g. at different temperatures, different pressures). Providing
two simulations at different state points therefore allows a validation of
the sampled ensemble.

Functions
---------
*Check NVT Ensemble:*
:func:`physicalvalidation.ensemble.check_nvt`

*Check NPT Ensemble:*
:func:`physicalvalidation.ensemble.check_npt`

Examples
--------
To validate the ensemble generated by the Nose-Hoover-thermostated
simulation in folder `examples/nh1`, a second simulation at different
temperature (but otherwise identical setup) is necessary. The results
of a second simulation at 310K can be found in folder `examples/nh2`.
After creating the data structure (using a different ensemble object),
the ensemble validation is then done as
::

   NVT_310 = EnsembleData('NVT', natoms=2700, volume=3.01125**3, temperature=310)
   nh2_data = parser.get_simulation_data(ensemble=NVT_310, topology=topo,
                                         edr='examples/nh2/water.edr',
                                         gro='examples/nh2/water.gro')


   from physicalvalidation import ensemble
   ensemble.check_nvt(nh1_data, nh2_data, total_energy=False)

The choice whether the total energy is chosen for the comparison or
only the potential energy (`total_energy=False`), is of lesser
importance in this case, as the kinetic energy does have the correct
distribution, as can be tested separately using the `kineticenergy`
module. The commands listed above will print results from different
analysis, including linear fit and maximum-likelihood analysis of
with both analytical and bootstrapped error estimate. As an example,
the output of the bootstrapped maximum-likelihood analysis looks like
::

   ---------------------------------------------
        Maximum Likelihood Analysis
   ---------------------------------------------
        df = -132.78305 +/- 2.01254
   ---------------------------------------------
        Estimated slope       vs.   True slope
   ---------------------------------------------
      0.012934 +/-    0.000196  |     0.012933
   ---------------------------------------------

   (That's 0.01 quantiles from true slope=0.012933, FYI.)

   ---------------------------------------------
    True dT =  10.000, Eff. dT =  10.001+/-0.152
   ---------------------------------------------

This indicates a nearly perfect ratio between the two distributions
and hence confirms that the expected ensemble is sampled.

The same analysis can be applied for the simulation using Berendsen
thermostat. In analogy to the Nose-Hoover example, a second simulation
at higher temperature can be found in folder `examples/ber2`, and the
analysis is called using
::

   ber2_data = parser.get_simulation_data(ensemble=NVT_310, topology=topo,
                                          edr='examples/ber2/water.edr',
                                          gro='examples/ber2/water.gro')
   ensemble.check_nvt(ber1_data, ber2_data, total_energy=False)

The output of the bootstrapped maximum-likelihood analysis now reads
::

   ---------------------------------------------
        Maximum Likelihood Analysis
   ---------------------------------------------
        df = 774.26128 +/- 18.27361
   ---------------------------------------------
        Estimated slope       vs.   True slope
   ---------------------------------------------
      0.022078 +/-    0.000520  |     0.012933
   ---------------------------------------------

   (That's 17.58 quantiles from true slope=0.012933, FYI.)
    (Ouch!)
   ---------------------------------------------
    True dT =  10.000, Eff. dT =  17.071+/-0.402
   ---------------------------------------------

This results indicate a large deviations form the expected ratio
between the distributions at different temperatures.

.. todo:: Check NPT example

Integrator validation
=====================
A simplectic integrator can be shown to conserve a constant of motion
(such as the energy in a microcanonical simulation) up to a fluctuation
depending on the integration time step chosen. Comparing two or more
constant-of-motion trajectories realized using different timesteps (but
otherwise unchanged simulation parameters) allows to check the
simplecticity of the integration. Note that lack of simplecticity does not
necessarily imply an error in the integration algorithm, it can also hint
at physical violations in other parts of the model, such as non-continuous
potential functions, unprecise handling of constraints, etc.

Functions
---------

Examples
--------
.. todo:: !

.. _`github page`: https://github.com/shirtsgroup/physical-validation
